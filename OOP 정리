객체지향 프로그래밍
    
    Tv[] tvArr = new Tv[3]; // tvArr -> {null, null, null}
    tvArr[0] = new Tv(); // 객체 생성은 따로 해줘야 한다

    변수 선언 위치에 따라 변수의 종류가 결정됨
        1. 멤버 변수: 클래스 변수, 인스턴스 변수
        2. 지역 변수: 메서드, 생성자, 초기화 블럭 내부 (매개변수도 지역변수이다)

        Class Variables {
            int iv;
            // [인스턴스 변수]
            // 인스턴스가 생성될 때 생성
            // 인스턴스를 생성해야 접근가능함
            // 인스턴스마다 고유한 상태를 유지해야하는 값인 경우
            
            static int cv;
            // [클래스 변수]
            // 클래스가 메모리에 올라갈 때 생성되어 프로그램이 종료될 때까지 유지됨.
            // 인스턴스 생성없이 접근가능하며 '클래스이름.클래스변수' 형식으로 사용
            // 모든 인스턴스들이 공통된 값을 공유할 수 있는 경우

            void method() {
                int lv = 0;
                // [지역 변수]
                // 변수 선언문이 실행될 때 생성되어 메서드가 종료될 때까지 유지됨.
            }
        }

    메서드
        1. 인자(argument)의 타입은 매개변수(parameter)의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다 (parameter가 더 높은 계층의 클래스). 
        2. return문에는 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다 (반환타입이 더 높은 계층의 클래스).
        3. 같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만, static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다. (인스턴스가 생성되었는지 보장할 수 없으므로)
        4. 메서드가 인스턴스 변수나 인스턴스 메서드를 사용하지않는 경우 static을 붙이는 것을 고려하자. 메서드 호출시간이 짧아져 성능 향상됨.
        5. void 타입인 경우 컴파일러가 자동으로 return;을 추가한다. void가 아닌 경우 반드시 return문이 있어야 한다.
        6. 매개변수 타입이 기본형일 때는 값이 복사, 참조형인 경우 주소 복사.

    JVM 메모리구조
        1. Method Area
            프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 클래스 데이터(클래스 변수도 포함)를 이곳에 저장한다.
        2. Call Stack
            메서드가 호출되면 호출된 메서드를 위한 메모리가 할당되며, 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 지워진다(지역 변수 포함).
        3. Heap
            생성되는 인스턴스(인스턴스 변수 포함)는 모두 이곳에 저장된다.

    오버로딩
        이름은 같으나 매개변수 개수 또는 타입이 다른 메서드를 정의하는 것
        * 반환 타입은 고려대상 아님

        가변인자를 사용하는 경우 가변인자는 제일 마지막 매개변수로 선언해야 한다. 그렇지 않으면 컴파일 에러 (가변인자인지 아닌지 구별할 방법이 없음)
        가변인자에는 인자가 없어도 되고 배열도 인자가 될 수 있다 (가변인자는 내부적으로 배열을 사용한다; 호출 시 매번 배열을 새로 생성하는 비효율이 숨어있기 때문에 꼭 필요한 경우에만 사용하자).
        가변인자가 아닌 배열로 매개변수를 선언한 경우에는 반드시 인자를 지정해 줘야하는 차이가 있다 (인자를 생략할 수 없으니 null이나 길이가 0인 배열을 넣어줘야 하는 불편함이 있다).

    생성자
        인스턴스 초기화 메서드
        이름은 클래스와 같고 리턴값이 없다.
        생성자도 오버로딩이 가능하다.
        new 연산자가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것은 아니다.

        기본생성자
            컴파일할 때, 생성자가 하나도 없는 경우 자동으로 추가된다. "클래스이름() {}"
            따라서, 생성자가 하나라도 정의되어 있는 경우에는 기본생성자는 생성되지 않는다.

        this()
            같은 클래스의 다른 생성자를 호출할 때 사용. 반드시 첫 줄에서만 사용가능.
            Car(String color) {
                this(color, "auto");
                door = 5;
            }
        
        this
            인스턴스 자신을 가리키는 참조변수, 모든 인스턴스 메서드에 지역변수로 숨겨진 채 존재.
            매개변수 이름이 인스턴스 변수이름과 같은 경우 구분을 위해 사용 (static method에서는 this를 사용할 수 없음. static method는 인스턴스 생성없이도 호출할 수 있으므로 메서드 호출시점에 인스턴스가 존재하지 않을 수 있기 때문)
            Car(String color) {
                this.color = color;
            }

    변수초기화
        멤버변수(클래스 변수, 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.
            boolean -> false
            char -> '\u0000'
            byte, short, int -> 0
            long -> 0L
            float -> 0.0f
            double -> 0.0d 또는 0.0
            참조형 변수 -> null
        
        멤버변수의 초기화 방법
            1. 명시적 초기화 (선언과 동시에 초기화; int door = 4 or Engine e = new Engine())
            2. 생성자
            3. 초기화 블럭 (인스턴스 초기화 블럭 { /* 메서드처럼 조건, 반복, 예외처리 등 자유롭게 사용 가능 */ } 클래스 초기화 블럭 static {})

        멤벼변수 초기화 시기와 순서
            1. 클래스 변수
                시점: 클래스가 처음 로딩될 때 단 한번 (클래스 멤버를 사용하거나 인스턴스를 생성할 때 등; 단, 클래스 로딩 시기는 JVM에 따라 다를 수 있는데 필요할 때 로딩하기도 하고 실행효율을 높이기 위해 미리 로딩하기도 함)
                순서: 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
            2. 인스턴스 변수
                시점: 인스턴스가 생성될 때 각 인스턴스마다
                순서: 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
            
    상속
        생성자와 초기화 블럭은 상속되지 않고, 멤버(멤버변수 + 메서드)만 상속된다.
        자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
        (접근 제어자가 private 또는 default인 멤버들은 상속되지 않는다기보다 상속은 받지만 자손 클래스로부터의 접근이 제한된다)

        상속관계 vs 포함관계
            상속: -은 -이다. (is-a)
            포함: -은 -을 가지고 있다. (has-a)
        
    오버라이딩
        조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
        1. 이름이 같고 2. 매개변수가 같고 3. 리턴타입이 같아야 한다.
        4. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다. (protected면 protected, public 가능)
        5. 조상 클래스의 메서드보다 많은 수(넓은 범위)의 예외를 선언할 수 없다.
        6. 인스턴스 메서드를 클래스 메서드(static)로 또는 클래스 메서드를 인스턴스 메서드로 변경할 수 없다.
            자손 클래스에서 동일한 이름, 매개변수, 리턴타입으로 클래스 메서드를 선언할 수 있으나 이것은 오버라이딩이 아닌 별개의 메서드를 선언한 것으로 '클래스이름.메서드이름()'으로 각각 호출.

    super
        조상 클래스로부터 상속받은 멤버를 참조하는데 사용하는 참조변수.
        조상 클래스로부터 상속받은 멤버도 자손 클래스의 멤버이므로 super대신 this를 사용할 수 있다.
        조상 클래스의 멤버(메서드 포함)와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우에만 super를 사용하는 것이 좋다.
        모든 인스턴스 메서드에는 this, super가 존재한다. static 메서드에서는 this. super를 사용할 수 없다.

    super()
        조상 클래스의 생성자를 호출하는데 사용.
        자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
        이 때, 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.
        생성자의 첫 줄에서 조상 클래스의 생성자를 호출하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버가 먼저 초기화되어 있어야 하기 때문.
        Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 한다. 그렇지 않으면 컴파일러는 생성자 첫 줄에 super()를 자동으로 추가한다.

    package
        모든 클래스는 반드시 하나의 패키지에 속해야 한다.
        한 소스파일에는 첫번째 문장으로 한 패키지 선언만 허용된다.
        자신이 속한 패키지를 지정하지 않은 클래스는 자동적으로 이름 없는 패키지에 속하게 된다.
    
    import
        import문은 프로그램 성능에 전혀 영향이 없다. 컴파일 시간이 아주 조금 더 걸릴 뿐.
        *을 사용하는 것이 하위 패키지의 클래스까지 포함하는 것은 아니다.
        java.util.*, java.text.* != java.*
        같은 패키지 내 클래스들은 import문을 지정하지 않고도 패키지 명을 생략할 수 있다.
        import static으로 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

    제어자(modifier)
        접근 제어자: public, protected, default, private
        그     외: static, final, abstract, native, transient, synchronized, volatile, strictfp

        사용가능한 제어자
            클래스: public, (default), final, abstract, static
            메서드: public, (default), protected, private, final, abstract, static
            멤버변수: public, (default), protected, private, final, static
            지역변수: final

        접근 제어자
            private: 같은 클래스 (메서드, 멤버변수; 생성자가 private인 클래스는 조상이 될 수 없다. 자손 클래스의 인스턴스를 생성할 때 조상 클래스의 생성자를 호출해야 하는데, 생성자의 접근 제어자가 private이므로 자손 클래스에서 호출하는 것이 불가능하기 때문. 클래스 앞에 final을 추가해서 상속할 수 없는 클래스라는 것을 알리는 것이 좋다. Math)
            default: 같은 패키지 (클래스, 메서드, 멤버변수)
            protected: 같은 패키지, 다른 패키지의 자손 클래스 (메서드, 멤버변수)
            public: 제한 없음 (클래스, 메서드, 멤버변수)

        static
            멤버변수: 클래스 변수가 된다.
            메서드: static 메서드가 된다.
            초기화 블럭: 클래스 변수 초기화
        
        final (대표적으로 String, Math)
            클래스: 상속할 수 없는 클래스가 된다.
            메서드: 오버라이딩을 할 수 없다.
            멤버변수, 지역변수: 상수가 된다. (보통 선언과 동시에 초기화하지만, 인스턴스 변수의 경우 생성자에서 초기화할 수 있다)
        
        abstract
            클래스: 클래스 내 추상 메서드가 있음을 의미
            메서드: 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알림.

        1. 메서드에 static과 abstract를 함께 사용할 수 없다. => static 메서드는 몸통이 있는 메서드만 사용가능
        2. 클래스에 abstract와 final을 함께 사용할 수 없다. => 모순
        3. abstract 메서드의 접근 제어자가 private일 수 없다. => 모순
        4. 메서드에 private과 final을 같이 사용할 필요는 없다. => 접근제어자가 private인 메서드는 오버라이딩할 수 없기 때문

    다형성(polymorphism)
        조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하는 것
        자손 타입의 참조변수로 조상 클래스의 인스턴스를 참조할 수는 없다.

        형변환
            자손타입 -> 조상타입: 형변환 생략가능 (업캐스팅)
            조상타입 -> 자손타입: 형변환 생략불가 (다운캐스팅)
        
        instanceof
            어떤 인스턴스의 instanceof 결과가 true인 것은 검사한 타입으로 형변환이 가능하다는 것을 의미한다.

        조상 클래스의 메서드를 자손 클래스가 오버라이딩한 경우 참조변수의 타입에 관계없이 실제 인스턴스 메서드 (오버라이딩된 메서드)가 호출되지만,
        멤버변수와 static 메서드는 참조변수의 타입에 영향을 받는다. 인스턴스 메서드만 영향을 받지 않는다.
        
        매개변수, 리턴타입에 자동 형변환되는 타입을 사용할 수 있음 (조상 클래스와 자기 자신)

    추상클래스(abstract class)
        추상 클래스로는 인스턴스를 생성할 수 없다. 추상메서드 중 하나라도 구현하지 않으면, 자손 클래스 역시 추상클래스로 지정해줘야 한다.
        추상 메서드가 없는 클래스를 abstract를 붙여 추상 클래스로 만드는 경우도 있는데, 아무런 내용이 없는 메서드들만 정의되어 있다. 이런 클래스는 인스턴스를 생성해봐야 할 수 있는 것이 없어 인스턴스를 생성하지 못하게 막아둔 것이다.
        abstract없이 구현부만 안쓰면 별 차이없을 것 같지만, abstract를 붙여 자손 클래스에서 추상 메서드를 반드시 구현하도록 강제하는 데 있다.

    인터페이스(interface)
        일종의 추상클래스. 구현하는 인터페이스 중 일부만 구현한다면, 자손 클래스에 abstract를 붙여줘야 한다.
        추상클래스와 달리 몸통을 가진 일반 메서드 또는 멤버변수를 가질 수 없다.
        오직 추상메서드와 상수만을 멤버로 가질 수 있다.
        
        interface 인터페이스이름 {
            public static final 타입 상수이름 = 값; // 모든 멤버변수는 public static final이며, 생략가능
            public abstract 메서드이름(매개변수 목록); // 모든 메서드는 public abstract 이며, 생략가능 (오버라이딩 메서드는 조상 메서드보다 넓은 범위의 접근 제어자를 사용해야하므로 자손 클래스의 메서드는 항상 public)
            // java8부터 static 메서드와 디폴트 메서드 사용 가능
        }

        인터페이스를 이용한 다중상속
            하나는 상속 다른 하나는 포함(인터페이스를 안써도 되지만 쓰면 다형성을 이용할 수 있다는 장점이 있다)하여 처리할 수 있다.
            
            AS-IS
                public class TV {
                    protected boolean power;
                    public void power() { power != power; }
                }

                public class VCR {
                    protected int counter;
                    public void play() { // TAPE 재생 }
                }

                public class TVCR extends TV {
                    private VCR vcr = new VCR();
                    public void play () { vcr.play(); }
                }

            TO-BE
                public class TV {
                    protected boolean power;
                    public void power() { power != power; }
                }

                public class VCR implements IVCR {
                    protected int counter;
                    public void play() { // TAPE 재생 }
                }

                interface IVCR {
                    public void play() { // TAPE 재생 }
                }

                public class TVCR extends TV implements IVCR {
                    private VCR vcr = new VCR();
                    public void play () { vcr.play(); }
                }

        인터페이스를 이용한 다형성
            인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며,
            인터페이스 타입으로의 형변환도 가능하다. (매개변수의 타입으로도 사용 가능)
            리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.

            interface Parser {
                public abstract void parse(String fileName);
            }

            class ParserManager {
                public static Parser getParser(String type) {
                    if(type.equals("XML")) {
                        return new XMLParser();
                    } else {
                        return new HTMLParser();
                    }
                }
            }

            class XMLParser implements Parser {
                public void parse(String fileName) { }
            }

            class HTMLParser implements Parser {
                public void parse(String fileName) { }
            }

            AS-IS
                XMLParser xmlParser = new XMLParser();
            TO-BE
                Parser parser = new XMLParser();
                or
                Parser parser = ParserManager.getParser("XML");

        인터페이스의 장점
            1. 개발시간 단축: 인터페이스를 구현한 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다.
            2. 클래스들 간 관계를 맺어줄 수 있다: 상속관계에 있지 않고, 같은 조상 클래스를 가지고 있지 않은 클래스들 간 하나의 인터페이스를 공동 구현하도록 함으로써 관계를 맺어줄 수 있다.
                상속트리를 하나 더 만들 수 있다!!!!!!!!!!
                [GroundUnit -> Marine, SCV, Tank]
                [AirUnit -> DropShip]
                [Repairable -> SCV, Tank, DropShip]
            3. 클래스간 직접적인 관계를 인터페이스를 이용해서 간접적인 관게로 변경하면, 한 클래스의 변경이 다른 클래스에 영향을 미치지 않게 할 수 있다.
                단, 구현 클래스를 제공하는 쪽에서는 인터페이스를 구현해야 하고, 제공받는 쪽에서도 인터페이스를 사용해야 한다.

        인터페이스에서 일부 메서드를 구현하지 않을 경우
            구현하지 않아도 되지만, 추상메서드라 몸통은 반드시 만들어줘야 한다.
            단, public void method() {}; 와 같이 만들어주면 호출하는 쪽에서 해당 메서드가 제대로 동작하지 않는 이유를 알기 어렵다.
            따라서, 메서드에서 에외를 던져주어 호출하는 쪽에서 기능이 동작하지 않는 이유를 명확히 알 수 있도록 하자 (ListIterator의 remove 메서드 java API 문서를 보자)
            
        default method
            디폴트 메서드와 기존 메서드간 충돌되는 경우
            1. 여러 인터페이스의 디폴트 메서드간 충돌
                인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
            2. 디폴트 메서드와 조상 클래스의 메서드간 충돌
                조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.

            복잡하면 그냥 오버라이딩 해버리면 그만..

    예외처리
        에러 종류
            컴파일 에러 - 컴파일 시에 발생하는 에러
            런타임 에러 - 실행 시에 발생하는 에러
            논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것

        자바에서는 런타임에 발생할 수 있는 오류를 에러와 예외 두가지로 구분했다.
        '에러'는 OutOfMemeoryError, StackOverflowError와 같이 일단 발생하면 복구할 수 없는 심각한 오류이고, '예외'는 발생하더라도 수습될 수 있는 비교적 덜 심각한 것이다.

        에외 클래스의 계층구조
            Object   -> Throwable   -> Exception    -> IOException
                                                    -> ClassNotFoundException
                                                    -> FileNotFoundException
                                                    -> DataFormatException 
                                                    -> ...
                                                    -> RuntimeException         -> ArithmeticException
                                                                                -> ClassCastExcepion
                                                                                -> NullPointerException
                                                                                -> ...
                                                                                -> IndexOutOfBoundsException
                                    -> Error        -> OutOfMemeoryError
                                                    -> ...
                                                    -> StackOverflowError
                                    
        RuntimeException은 프로그래머의 실수로 발생하는 예외 (예외처리를 강제하지 않음; unchecked exception. Error도 unchecked exception. try-catch 블럭으로 처리할 수 없기 때문)
        Exception(RuntimeException 제외)은 사용자 실수와 같은 외적인 요인에 의해 발생하는 예외 (예외처리를 강제함. 예외처리가 없으면 컴파일조차 되지 않음; checked exception)

        throws에는 checked exception만 보통 씀 (unchecked exception을 써도 문제되지는 않지만)

        예외가 발생한 경우 try -> catch -> finally, 예외가 발생하지 않은 경우 try -> finally
        catch 괄호내에 선언된 예외클래스로 instanceof이 true가 반환되면 해당 catch 블럭이 실행된다.

        기존의 예외 클래스는 주로 Exception을 상속받아서 checked 에외로 작성하는 경우가 많았지만,
        요즘은 예외처리를 선택적으로 할 수 있도록 RuntimeException을 상속받아서 작성하는 쪽으로 바뀌어가고 있다.
        checked 예외는 반드시 예외처리를 해줘야 하기 때문에 예외처리가 불필요한 경우에도 try-catch를 넣어서 코드가 복잡해지기 때문이다.
        프로그래밍 환경이 달라진 만큼 필수적으로 처리해야만 할 것 같았던 예외들이 선택적으로 처리해도 되는 상황으로 바뀌는 경우가 종종 발생하고 있다.
        그래서 필요에 따라 예외처리의 여부를 선택할 수 있는 unchecked 예외가 강제적인 checked 예외보다 더 환영받고 있다.

    Collection Framework
        List, Set extends Collection
            List: 순서가 있고, 데이터 중복을 허용 (ArrayList, LinkedList)
            Set: 순서가 없고, 데이터 중복을 허용하지 않음 (HashSet, TreeSet) // 이미 동일한 값이 있는 경우 저장에 실패하고 false 반환
        
        Map (not extends Collection)
            순서가 없고, 키는 중복을 허용하지 않고 값은 중복을 허용 (HashMap, TreeMap) // 이미 동일한 키가 있는 경우 덮어 씌움
            Map.Entry: Map 인터페이스의 내부 인터페이스, Map에 저장되는 key-value 쌍을 다루기 위해 정의해 놓은 것으로 Map 인터페이스를 구현하는 클래스에서는 Map.Entry 인터페이스도 함께 구현해야 한다.
        
        Vector, Hashtable은 쓰지말자.. 개선된 ArrayList, HashMap을 쓰자.
        
        List
            ArrayList
                Object 배열을 이용해서 데이터를 순차적으로 저장한다.
                배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열에 복사한 다음에 저장한다.
                ArrayList를 생성할 때, 저장할 요소의 개수를 고려해서 실제 저장할 개수보다 약간 여유있는 크기로 하는 것이 좋다 (너무 큰 배열은 공간낭비).
                
                배열의 중간에 위치한 객체를 추가하거나 삭제하는 경우 System.arraycopy()를 호출해서 데이터를 이동시켜줘야 하므로 시간이 오래 걸린다.
                한 요소가 삭제되면 빈 공간을 채우기 위해 나머지 요소들이 자리이동을 하는 것에 명심하자 (두개 이상의 요소가 삭제될 수 있는 경우 뒤에서 부터 iteration하도록 하자)
                순차적으로 저장하거나 마지막 요소부터 삭제하는게 좋다.
            
            LinkedList (실제로 더블 링크드 리스트로 구현되어 있음)
                비순차적인 추가, 삭제가 빠르다 (순차적인 추가, 삭제는 ArrayList가 빠르다. 단, ArrayList 크기가 충분히 커서 배열복사가 일어나지 않는다는 전제)
            
            정리
                ArrayList vs. LinkedList
                읽기: 빠르다 vs. 느리다 (데이터가 많을수록 접근성이 떨어짐; ArrayList는 random access가 가능하나, LinkedList는 처음부터 차례대로 따라가야만 하므로)
                추가/삭제: 느리다 vs. 빠르다 (단, 순차적인 추가/삭제는 ArrayList가 더 빠름)
                
                데이터가 크지 않다면 뭘 써도 사실 상관없음.. 그래도 각각의 장단점을 잘 이해하고 상황에 따라 적합한 것을 사용하자.

                데이터 개수가 변하지 않는 경우라면 ArrayList
                데이터 개수의 변경이 잦다면 LinkedList
                조합해서 사용하는 것도 좋은 방법! 처음 데이터를 저장할 때는 ArrayList를 사용하고 작업할 때는 LinkedList로 데이터를 옮겨서 작업하면 좋은 효율을 낼 수 있다.

                ArrayList al = new ArrayList(100000);
                for(int i=0; i<100000; i++) al.add(i+"");
                LinkedList ll = new LinkedList(al)
                for(int i=0; i<1000; i++) ll.add(500, "X");

                ArrayList, LinkedList에만 있는 메서드를 쓰는게 아니라면 List를 참조변수로 사용하도록 하자.
                (성능상의 이유나 테스트 목적으로 구현클래스를 바꾸려면 선언문만 바꾸고 나머지 코드는 검토하지 않아도 되는데 참조변수가 List이므로 List에 정의되지 않은 메서드를 사용하지 않았을 것이므로
                그러나 구현클래스를 참조변수로 하면 선언문 이후 나머지 코드도 검토가 필요하다.)

            Queue
                Stack은 LIFO이므로 ArrayList로 구현이 적합하며, Queue는 FIFO이므로 LinkedList로 구현이 적합
                (Queue는 인터페이스로 정의되어 있고, LinkedList가 실제로 Queue를 구현하고 있음; Queue queue = new LinkedList();)

                PriorityQueue
                    Queue 인터페이스 구현체 중 하나로 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼낸다.
                    null은 저장할 수 없고, 저장하려고 하면 NPE가 난다.
                    배열을 사용하며, 자료구조로 힙을 사용함
            
            Iterator, ListIterator, Enumeration
                Enumeration은 Iterator의 구버전. 가능한 Iterator를 사용하자.
                ListIterator는 Iterator의 기능을 향상시킨 것. 양방향으로 이동이 가능. 단, ArrayList, LinkedList와 같이 List 인터페이스를 구현한 컬렉션에서만 사용할 수 있음.
                
                Iterator()는 Collection 인터페이스에 정의된 메서드로 List, Set 인터페이스를 구현한 클래스에 사용할 수 있음
                Map 인터페이스를 구현한 클래스는 Iterator()를 직접 호출할 수 없고, keySet(), entrySet()과 같은 메서드를 통해 키와 값을 따로 Set()형태로 가져오고 Iterator()를 호출해야 Iterator를 얻을 수 있다.

            Arrays
                배열을 다루는데 유용한 메서드가 있다. (모두 static 메서드)
                
                배열복사: copyOf(), copyOfRange()
                배열채우기: fill(), setAll()
                정렬, 탐색: sort(), binarySearch()
                문자열 비교 및 출력: equals(), toString(), deepEquals(), deepToString() // 다차원 배열의 경우 deep~을 쓸 것
                List로 변환: asList(Object... a) // 반환한 List에 추가, 삭제가 불가능하다. 저장된 내용은 변경가능하다. 크기를 변경할 수 있는 List가 필요한 경우 List list = new ArrayList(Arrays.asList(1,2,3));
            
            Comparator와 Comparable
                Comparable 기본 정렬기준(보통 오름차순)을 구현하는데 사용
                Comparator 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용

                Arrays.sort(Object[] a) // 객체 배열에 저장된 객체가 구현한 Comparable에 의한 정렬
                Arrays.sort(Object[] a, Comparator c) // 지정한 Comparator에 의한 정렬

                역순으로 만들고 싶은 경우 compareTo 결과에 -1을 곱하는 compare 메서드를 만들자.

        Set
            HashSet
                load factor는 컬렉션 클래스에 저장공간이 가득 차기 전에 미리 용량을 확보하기 위한 것으로 이 값을 0.8로 지정하며, 저장공간이 80%가 채워졌을 때 용량이 두 배로 늘어난다. 기본값은 0.75이다.
                새로운 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals(), hashCode()를 호출하기 때문에 eqauls()와 hashCode()를 목적에 맞게 오버라이딩해야 한다.
                ** eqauls를 재정의해야 한다면 반드시 hashCode도 재정의해서 equals() 결과가 true인 두 객체의 해시코드값이 항상 같도록 해줘야 한다.
                hashCode는 1.8부터 추가된 hash() 메서드를 사용하자. Objects.hash(인스턴스 변수들...)
                String 클래스는 문자열의 내용을 해시코드로 만들어 내어 내용이 같은 문자열에 대한 해시코드는 같다. 반면 Object 클래스는 객체 주소로 해시코드를 만들어 내어 실행할 때마다 해시코드 값이 바뀔 수 있다.

                hashCode() 다음 조건을 만족해야 한다.
                    1. equals 메서드에 사용된 멤버변수의 값이 바뀌지 않는 한 인스턴스의 해시코드는 변하지 않아야 한다.
                    2. equals 비교에서 true면 두 객체의 hashCode가 같아야 하고, false면 같거나 달라도 됨.
                        그러나, 컬렉션 성능(해싱)을 향상시키기 위해서는 다른 값을 반환하는 것이 좋다
                        (해시코드가 같다고 해서 equals 결과가 true인 것은 아니다.)
                
            TreeSet
                이진 검색 트리(레드블랙트리)를 사용.
                정렬, 검색, 범위 검색에 높은 성능을 보이는 자료구조.
                
                트리는 요소 추가 시 저장위치를 찾아야 하고 삭제하는 경우 트리 일부를 재구성해야하므로 링크드 리스트보다 추가/삭제에 대한 비용이 크다.
                그 대신 배열이나 링크드 리스트에 비해 검색과 정렬기능이 뛰어나다.

        Map
            HashMap vs. TreeMap
                검색에 관한 대부분의 경우 HashMap이 뛰어나다.
                단, 범위검색이나 정렬이 필요한 경우에는 TreeMap을 쓰자.

        Collections (클래스)
            Arrays가 배열에 관련된 메서드를 제공하는 것처럼, Collections는 컬렉션과 관련된 메서드를 제공한다.

            동기화 컬렉션
            변경불가 컬렉션
            싱글톤 컬렉션
            한 종류의 객체만 저장하는 컬렉션
    
    Generics
        다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능.
        객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.

        지네릭 클래스
            example
                class Box<T> {
                    ArrayList<T> list = new ArrayList<T>();

                    void add(T item) { list.add(item); }
                    T get(int i) { return list.get(i); }
                    ArrayList<T> getList() { return list; }
                    int size() { return list.size(); }
                    public String toString() { return list.toString(); }
                }

            용어
                Box<T>: 지네릭 클래스
                Box: 원시 타입 (raw type)
                T: 타입 변수 또는 타입 매개변수

                Box<String> b = new Box<String>();
                지정된 타입(여기에서는 String)을 parameterized type이라 부름

            지네릭 타입을 지정하지 않고 사용하는 경우 (Object로 간주) 에러는 아니지만 unchecked or unsafe operation 경고가 발생.
                Box b = new Box();
                b.setItem("ABC");
                b.setItem(new Object());

            제약
                T의 자료형이 결정되는 시점은 지네릭 클래스의 인스턴스가 생성될 때.
                T의 자료형이 정해지기 전에 접근할 수 있는 것들은 사용 불가.

                static 멤버
                    모든 객체에 동일하게 동작해야하는 static 멤버에 타입 변수 T를 사용할 수 없다.
                    static 멤버는 parameterized type과 관계없이 동일한 것이어야 하기 때문이다.
                    즉, item이 static 멤버변수라고 했을 때, Box<Apple>.item과 Box<Grape>.item이 다를 수 없다.
                배열
                    지네릭 타입의 배열 생성은 허용되지 않는다. (x) new T[10];
                    참조변수를 지네릭 타입의 배열로 선언하는 것은 가능. (o) T[] arr;
                    new 연산자는 컴파일 시점에 타입 T가 무엇인지 정확히 알아야 한다. instanceof 연산자도 같은 이유로 T를 피연산자로 사용할 수 없다.

            객체 생성
                반드시! 참조변수와 생성자에 대입된 parameterized type이 같아야 한다.
                Box<Apple> appleBox = new Box<Apple>();
                Box<Fruit> appleBox = new Box<Apple>(); // (x) 상속관계도 안됨
                Box<Apple> appleBox = new FruitBox<Apple>(); // (o) 지네릭 클래스의 타입이 상속관계에 있고, parameterized type이 같은 것은 괜찮다.
                Box<Apple> appleBox = new Box<>(); // (o) JDK1.7부터 생략가능

                Box<Fruit> fruitBox = new Box<Fruit>();
                fruitBox.add(new Fruit()); // (o)
                fruitBox.add(new Apple()); // (o) Fruit의 자손들은 이 메서드의 인자가 될 수 있다.

            제한
                extends: 특정 타입의 자손들만 대입할 수 있게 제한할 수 있음 (여러 타입의 인터페이스를 구현하는 경우에는 &로 연결. T extends Fruit & Eatable)
                super: 특정 타입의 조상들만 대입할 수 있게 제한할 수 있음

                <? extends T> 상한 제한. T와 그 자손들만 가능
                <? super T> 하한 제한. T와 그 조상들만 가능
                <?> 제한 없음. <? extends Object>와 동일

        지네릭 메서드
            지네릭 클랙스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 별개의 것이다.
            같은 타입 문자 T를 사용한다 해도 같은 것이 아니라는 것에 주의하자.

        지네릭 타입의 형변환
            지네릭 타입과 넌지네릭 타입간 형변환은 항상 가능. 단, 경고.
                Box box = null;
                Box<Object> objBox = null;
                box = (Box)objbox; // (o)
                objbox = (Box<Object>)box; // (o)

            타입 매개변수가 다른 지네릭 타입간에는 불가능
                Box<Object> objBox = null;
                Box<String> strBox = null;
                objBox = (Box<Object>)strBox; // (x)
                strBox = (Box<String>)objBox; // (x)

            참조변수 지네릭 클래스의 타입 매개변수가 와일드 카드인 경우 (타입 매개변수 다형성을 쓰고 싶으면 extends, super를 사용하자. 매개변수 자체가 조상클래스라고 해도 다형성은 불가능하니까!)
                Box<? extends Fruit> fruitBox = new Box<Apple>(); // (o)

            PECS

    Anotation
        표준 애너테이션
            @Override
            @Deprecated
            @SuppressWarnings
            @SafeVarargs
            @FunctionalIntterface: 추상메서드가 하나뿐이어야 한다는 제약
            @Native
            
            메타 에너테이션: 에너테이션을 정의하는 데 사용하는 에너테이션
            @Target
            @Documented
            @Inherited
            @Retention
            @Repeatable


    Lambda
        람다식은 함수형 인터페이스로 참조할 수 있다.
        함수형 인터페익스에는 오직 하나의 추상메서드만 정의되어 있어야 한다.
        그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문이다.
        @FunctionalIntterface를 붙이면 컴파일러가 함수형 인터페이스를 올바르게 작성하였는지 확인해주므로 반드시 붙이자.

        함수형 인터페이스를 메서드의 매개변수 또는 반환타입으로 지정하여 람다식을 주고 받을 수 있다.

        람다식 내에서 참조하는 지역변수는 final이 붙지 않았어도 상수로 간주한다. 해당 지역변수는 람다식 내에서나 다른 어느 곳에서도 값을 변경할 수 없다.
        반면, 인스턴스 변수는 변경할 수 있다.

        java.util.function
            java.lang.Runnable      / void run()
            Supplier<T>             / T get()
            Consumer<T>             / void accept(T t)
            Function<T,R>           / R apply(T t)
            Predicate<T>            / boolean test(T t)

            매개변수가 2개인 함수형 인터페이스
            BiConsumer<T,U>         / void accept(T t, U u)
            BiFunction<T,U,R>       / R apply(T t, U u)
            BiPredicate<T,U>        / boolean test(T t, U u)
            
            3개 이상의 매개변수가 필요한 경우에는 직접 만들어서 사용해야 한다.
            @FunctionalIntterface
            interface TriFunction<T,U,V,R> {
                R apply(T t, U u, V v);
            }

            UnaryOperator<T>        / T apply(T t)
            BinaryOperator<T>       / T apply(T t, T t)

            기본형을 사용하는 함수형 인터페이스
            DoubleToIntFunction     / int apply(double d)
            ToIntFunction           / int applyAsInt(T value)
            intFunction             / R apply(int value)
            ObjIntConsumer          / void accpet(T t, int i)

        Function의 합성과 Predicate의 결합
            java.util.function 패키지의 함수형 인터페이스에는 추상메서드 외에도 default 메서드와 static 메서드가 정의되어 있다.
                Function
                    default <V> Function<T,V> andThen(Function<? super R, ? extends V> after)
                    default <V> Function<V,R> compose(Function<? super V, ? extends T> before)
                    static <T> Function<T,T> identity()

                Predicate
                    default Predicate<T> and(Predicate<? super T> other)
                    default Predicate<T> or(Predicate<? super T> other)
                    default Predicate<T> negate()
                    static <T> Predicate<T> isEqual(Object targetRef)

        메서드 참조
            하나의 메서드만 호출하는 람다식은 '클래스이름::메서드이름' 또는 '참조변수::메서드이름'으로 바꿀 수 있다. 
            (생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다. () -> new MyClass() / MyClass::new
            매개변수의 개수에 따라 알맞은 함수형 인터페이스를 사용하면 된다. (i, s) -> MyClass::new)
            
                static 메서드 참조: ClassName::method
                인스턴스 메서드 참조: ClassName::method
                특정 객체 인스턴스 메서드 참조: obj::method

    Stream
        스트림은 데이터 소스를 변경하지 않는다. 읽거나 새로운 컬렉션이나 배열을 반환할 뿐.
        스트림은 1회용이다. Iterator로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼 스트림도 한번 사용하면 닫혀서 다시 사용할 수 없다.
        오토박싱&언박싱의 비효율을 줄이기 위해 기본형을 다루는 스트림이 있다 (IntStream, LongStream, DoubleStream)
        스트림은 기본적으로 sequential하다. 병렬 처리하기 위해서는 parallel 메서드를 호출하면 된다. (parallet, sequential은 새로운 스트림을 생성하는 것이 아니라 스트림의 속성을 변경할 뿐이다)

        중간연산: 연산 결과가 스트림인 연산, 스트림에 연속해서 중간연산할 수 있음 (lazy 연산; 최종연산 전까지는 중간연산은 수행되지 않는다.)
        최종연산: 연산 결과가 스트림이 아닌 연산, 스트림의 요소를 소모하므로 단 한번만 가능

        Stream 만들기
            컬렉션: Colllection.stream()
            배열: Stream.of(T... value), Stream.of(T[]), Arrays.stream(T[]), Arrays.stream(T[] array, int startInclusive, int endExclusive)
            기본형 스트림
                IntStream.of(int... value), IntStream.of(int[]), Arrays.stream(int[]), Arrays.stream(int[] array, int startInclusive, int endExclusive)
                IntStream.range(int begin, int end)
                IntStream.rangeClosed(int begin, int end) // 경계포함
                new Random().ints().limit(5) // ints()는 무한 스트림이므로 스트림 크기를 제한해주어야 한다.
                new Random().ints(5)
                new Random().ints(1,5) // 난수범위 1,2,3,4
            람다식 (무한 스트림)
                Stream.iterate(0, n -> n+2) // 0, 2, 4, 6, ... 이전 결과를 다음 계산에 사용
                Stream.generate(Math::random) // 이전 결과를 다음 계산에 사용하지 않음
            
        Stream 연결
            Stream.concat(Stream.of(...), Stream.of(...))

        Stream 중간연산
            skip() // 건너뛰기
            limit() // 자르기
            filter()
            distinct()
            sorted()
            map()
            peek() // 조회. 스트림의 요소를 소모하지 않으므로 연산 사이에 여러 번 끼워 넣어도 문제되지 않는다.
            mapToInt(), maptoLong(), mapToDouble() // 기본형 스트림으로 변환
            sum(), average(), max(), min(), summaryStatistics()
            mapToObj(), boxed()
            flatMap()                
                1.
                Stream<String[]> arrStrm = Stream.of(
                    new String[]{"a", "b", "c"},
                    new String[]{"d", "e", "f"}
                );

                Stream<Stream<String>> strmStrm = arrStrm.map(Arrays::stream);
                Stream<String> strStrm = arrStrm.flatMap(Arrays::stream);

                2.
                String[] lineArr = {
                    "Believe or not It is true",
                    "Do or do not There is no try",
                };

                Stream<String> strm = Arrays.stream(lineArr);
                Stream<Stream<String>> strmStrm = strm.map(line -> Stream.of(line.split(" ")));
                Stream<String> strStrm = strm.flatMap(line -> Stream.of(line.split(" ")));

                3.
                Stream<String> strStrm = Stream.of("a","b","c");
                Stream<String> strStrm2 = Stream.of("d","e","f");
                Stream<Stream<String>> strmStrm = Stream.of(strStrm, strStrm2);
                Stream<String> strm = strmStrm
                    .map(s -> s.toArray(String[]::new))
                    .flatMap(Arrays::stream);
                
        Stream 최종연산
            void forEach(Consumer<? super T> action)
            boolean allMatch(Predicate<? super T> predicate)
            boolean anyMatch(Predicate<? super T> predicate)
            boolean noneMatch(Predicate<? super T> predicate)
            Optional<T> findFirst()
            Optional<T> findAny() // 병렬 스트림인 경우 findAny를 사용해야 한다.
            
            long count()
            Optional<T> max(Comparator<? super T> comparator)
            Optional<T> min(Comparator<? super T> comparator)

            count, max, min 보다 reduce(), collect()를 보통 더 많이 사용.
            Optional<T> reduce(BinaryOperator<T> accumulator) // 처음 두 요소로 연산한 결과를 가지고 다음 요소와 연산한다.
            T reduce(T identity, BinaryOperator<T> accumulator) // 초기값과 스트림의 첫번째 요소를 연산의 시작으로 한다. 스트림의 요소가 하나도 없는 경우 초기값을 반환하므로 반환 타입이 Optional<T>가 아닌 T이다.
            U reduce(U identity, BinaryOperator<U,T,U> accumulator, BinaryOperator<U> combiner) // 병렬 스트림 용도

        collect()
            collect() 스트림의 최종연산, 매개변수로 컬렉터를 필요로 한다. (sort할 때 Comparator가 필요한 것처럼 collect할 때 Collector가 필요하다)
            Collector 인터페이스, 컬렉터는 이 인터페이스를 구현해야한다.
            Collectors 클래스, static 메서드로 미리 작성된 컬렉터를 제공한다.

            스트림을 컬렉션과 배열로 반환
                toList, toSet
                toMap (키와 값을 쌍으로 저장해야하므로 객체의 어떤 필드를 키로 사용할지와 값으로 사용할지를 지정해줘야 함; toMap(Product::getId, Function.identity()))
                toCollection (생성자 참조를 매개변수로 넣어줘야 함; toCollection(ArrayList::new))
                toArray (생성자 참조를 매개변수로 넣어줘야 함; toArray(Student[]::new))

            통계
                counting(), summingInt(), averagingInt(), maxBy(), minBy()
            
            리듀싱
                reducing()
            
            문자열 결합
                joining()

            그룹화와 분할
                partitioningBy()
                    Collector partitioningBy(Predicate predicate)
                    Collector partitioningBy(Predicate predicate, Collector downstream)
                
                    partitioningBy가 빠르다. Predicate으로 가능하면 partitioningBy를 사용하자.
                    그룹화와 분할의 결과는 Map에 담긴다.

                    Map<Boolean, List<Student>> studentsBySex = stuStream.collect(partitioningBy(Student::isMale));
                    List<Student> maleStudents = stuBySex.get(true);
                    List<Student> femaleStudents = stuBySex.get(false);

                    Map<Boolean, List<Student>> studentsBySex = stuStream.collect(partitioningBy(Student::isMale, counting()));
                    studentsBySex.get(true); // 남학생 수
                    studentsBySex.get(false); // 여학생 수

                    Map<Boolean, Optional<Student>> topScoreBySex = stuStream.collect(partitioningBy(Student::isMale, maxBy(comparingInt(Student::getScore))));
                    topScoreBySex.get(true); // 최고점수를 가진 남학생
                    topScoreBySex.get(false); // 최고점수를 가진 여학생

                    Map<Boolean, Map<Boolean, List<Student>>> failedStuBySex = stuStream.collect(
                        partitioningBy(Student::isMale,
                            partitioningBy(s -> s.getScore() < 150)
                        )
                    );
                    List<Student> failedMaleStu = failedStuBySex.get(true).get(true);
                    List<Student> failedFemaleStu = failedStuBySex.get(false).get(true);

                groupingBy()
                    Collector groupingBy(Function classifier)
                    Collector groupingBy(Function classifier, Collector downstream)
                    Collector groupingBy(Function classifier, Supplier mapFactory, Collector downstream)
                    
                    Map<Integer, List<Student>> stuByClassRoom = stuStream.collect(groupingBy(Student::getClassRoom)); // 기본적으로 List<T>에 담는다.
                    Map<Integer, List<Student>> stuByClassRoom = stuStream.collect(groupingBy(Student::getClassRoom, toList()));
                    Map<Integer, HashSet<Student>> stuByClassRoom = stuStream.collect(groupingBy(Student::getClassRoom, toCollection(HashSet::new)));
                    Map<Student.Level, Long> stuByLevel = stuStream.collect(groupingBy(s -> {
                        if(s.getScore() >= 200) return Student.Level.HIGH;
                        else if(s.getScore() >= 100) return Student.Level.MID;
                        else return Student.Level.LOW;
                    }, counting()));
                    Map<Integer, Map<Integer, List<Student>>> stuByHakAndBan = stuStream
                        .collect(groupingBy(Student::getHak,
                            groupingBy(Student::getBan)
                        ));


                    
                



    Optional
        pulbic final class Optional<T> {
            private final T value;
        }

        반복된 if문 체크를 Optional에 정의된 메서드로 대체하여 간단히 처리 가능

        Optional 생성
            of, ofNullable: 참조변수의 값이 null일 가능성이 있으면, ofNullable을 사용해야 한다. of를 사용하면 NPE.
            empty: 참조변수를 기본값으로 초기화할 때. 내부적으로 null을 저장하고 있다.

        Optional 값처리
            get, orElse: 저장된 값을 가져올 때. 값이 null일 때는, NoSuchElementException이 발생한다. 이 때를 대비해서 orElse()로 값을 지정할 수 있다.
                Optional<String> optVal = Optinal.of("abc");
                String str1 = optVal.get();
                String str2 = optVal.orElse(""); // optVal에 저장된 값이 null일 때는 ""을 반환
            orElseGet: orElse 변형으로 null을 대체할 값을 반환하는 람다식을 지정할 수 있음
            orElseThrow: orElse 변형으로 null일 대 지정된 예외를 발생시킬 수 있음

            filter, map, flatMap
                map의 결과가 Optional<Optional<T>>일 때, flatMap을 사용하면 Optional<T>를 결과로 얻는다.
                만일 Optional 객체의 값이 null이면, 이 메서드들은 아무 일도 하지 않는다.
            
            isPresent
                Optional 객체의 값이 null이면 false를, 아니면 true를 반환한다.
            
            ifPresent
                값이 있으면 주어진 람다식을 실행하고, 없으면 아무 일도 하지 않는다.

    Thread


            


        




        




        
